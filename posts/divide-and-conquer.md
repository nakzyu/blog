---
title: 알고리즘 - 분할정복
description: 분할정복의 개념과 이진탐색, 퀵 정렬
publishedDate: "2022-03-27 18:34:00"
tag: CS
---

## 분할정복

### 분할정복 방법

- 순환적으로recusivley 문제를 푸는 하향식top-down 접근 방법

  - 주어민 문제의 입력을 더이상 나눌 수 없을 때까지, 두 개 이상의 작은 문제를 순환적으로 분할
  - 분할된 작은 문제들을 각각 해결한 후 이 해들을 결합해서 원래 문제의 해를 구하는 방식

- 특징
  - 분할된 작은 문제는 원래 문제와 동일 (입력 크기만 작아짐)
  - 분할된 작은 문제는 서로 독립적
    - 순환적 분할 및 결과 통합이 가능

### 분할정복 방법의 처리 단계

- 분할
  - 주어진 문제를 여러 개의 작은 문제로 분할한다.
- 정복
  - 작은 문제를 순환적으로 분할
  - 만약 작은 문제가 더 이상 분할되지 않을 정도로 크기가 충분히 작다면 순환호출 없이 작은 문제의 해를 구한다.
- 결합
  - 작은 문제에 대해 정복된 해를 결합하여 원래 문제의 해를 구한다
    - 결합 단계가 없는 문제도 존재한다.

### 분할정복 알고리즘 예

- 이진 탐색
- 퀵 탐색
- 합병 정렬
- 선택 문제

### 이진 탐색

- 정렬된 상태의 입력 데이터에 대한 효과적인 탐색 방법

  - 오름차순으로 정렬되었다고 가정

- 배열의 가운데 원소 `A[mid]`와 탐색키 `x`를 비교
  - 탐색키 = 가운데 원소 -> 탐색성공(인덱스 `mid`반환 후 종교)
  - 탐색키 < 가운데 원소 -> 이진탐색(원래 크기 1/2인 왼쪽 부분배열) 순환 호출
  - 탐색키 > 가운데 원소 -> 이진탐색(원래 크기 1/2인 오른쪽 부분배열) 순환 호출

* 탐색을 반복할 때 마다 대상 원소의 개수가 1/2로 감소

### 이진탐색에서의 적용

- 분할
  - 배열의 가운데 원소를 기준으로 왼쪽와 오른쪽 부분배열로 분할. 탐색키와 가운데 원소가 같으면 가운데 원소의 배열 인덱스를 반환/종료
- 정복
  - 탐색키가 가운데 원소보다 작으면 왼쪽 부분배열을 대상으로 이진 탐색을 순환 호출, 크면 오른쪽 부분배열을 대상으로 이진탐색을 순환 호출
- 결합
  - 필요없음 (부분배열에 대해서 탐색 결과가 직접 반환)

### 이진탐색 특징

- 입력 배열의 데이터가 정렬된 경우에 대해서만 적용 가능
- 삽입/삭제 연산은 부가적인 데이터 이동을 수반
  - 데이터의 정렬 상태 유지를 위해 평균 n/2개의 데이터 이동이 발생
    - 삽입/삭제가 빈번한 응용에서는 부적합

### 퀵 정렬

- 특정 원소를 기준으로 주어진 배열을 두 부분배열로 분할하고, 각 부분배열에 대해서 퀵 정렬을 순환적으로 적용하는 방식

  - 오름차순으로 정렬한다고 가정

- 피벗pivot
  - 주어진 배열을 두 부분배열로 분한할 때 기준이 되는 특정 원소
    - 보통 주어진 배열의 첫번째 원소로 지정

### 퀵정렬에서의 적용

- 분할
  - 피벗을 기준으로 주어진 배열을 두 부분배열로 분할한다.
- 정복
  - 두 부분배열에 대해서 퀵 정렬을 순환적으로 적용하여 각 부분배열을 정렬한다
- 결합
  - 필요없음

### 퀵정렬 성능분석 - 최악의 경우

- 배열이 항상 `O:n-1` 또는 `n-1:0`으로 분할되는 경우 (극심한 불균형적 분할)
  - 피벗만 제자리를 잡고 나머지 모든 원소가 하나의 부분배열이 되는 경우

* 피벗이 항상 부분배열의 최솟값 또는 최댓값이 되는 경우

* 입력 데이터가 정렬된 경우 AND 피벗을 배열의 처음 원소로 정한 경우

$T(n) = T(n-1) + T(0) + \theta(n)$ 단, $(n>0), T(0) = 0$

$T(n) = O(n^2)$

- 등차수열의 합을 Big O 로 나타낸다고 생각하면 쉽게 이해할 수 있음
  - $n(n+1)/2$를 Big O로 나타내면 $O(n^2)$

### 퀵정렬 성능분석 - 최선의 경우

- 배열이 항상 n/2:n/2 로 분할되는 경우
- 가장 균형적인 분할
  - 피벗을 중심으로 항상 동일한 크기의 두 부분배열로 분할되는 경우 => 피벗이 항상 부분배열의 중간값이 되는 경우

$T(n) = T(\frac{n}{2}) + T(\frac{n}{2}) + \theta(n)$ 단, $(n>1), T(1) = 1$

$T(n) = 2T(\frac{n}{2}) + \theta(n)$

$T(n) = O(n\log n)$

### 퀵정렬 성능분석 - 평균적인 경우

- 피벗은 동일한 확률로서 분할 후 배열의 어느곳에나 위치 가능

$T(1) = T(0) = 0$

$T(n) = \frac{1}{n}\sum_{i=1}^{n}(T(i-1) + T(n-i) + \theta(n) )$, $n \geq{2}$

$T(n) = O(n\log n)$

### 퀵정렬 수행시간 특징

- 최선/평균 수행시간 => $O(n\log n)$
- 최악 수행시간 => $O(n^2)$
  - 피벗 선택의 임의성만 보장되면 평균 성능을 보일 가능성이 매우 높음
  - 배열에서 임의의 값을 선택한 후, 배열의 처음 원소와 서로 교환한 후 정렬 수행을 통해 최악의 수행이 일어날 확률을 보정 할 수 있음
