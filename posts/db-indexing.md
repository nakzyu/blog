---
title: 데이터베이스 - [인덱싱 1]
description: 인덱스의 개념과 순서 인덱스, B트리 인덱스
publishedDate: "2022-03-15 06:53:00"
tag: CS
---

# 인덱싱

## 인덱스의 이해

### 인덱스의 개념

- 데이터 검색에서 발생하는 비효율적인 데이터 입출력 문제를 해결하기 위한 목적으로 시작

  - 인덱스
    - DBMS에서 요청된 레코드에 빠르게 접근할 수 있도록 지원하는 데이터와 관련된 부가적 구조
  - 인덱싱
    - 인덱스를 구성하고 생성하는 작업

- 인덱스의 탐색키를 이용하여 해당 레코드가 저장된 블럭을 디스크 저장장치 또는 메모리에서 파악하여 해당 블럭을 빠르게 적재

- 탐색키
  - 파일에서 레코드를 찾는데 사용되는 컬럼이나 컬럼의 집합

### 인덱스 기반의 검색과정

- 레코드의 데이터 전체를 메모리에 올리는것이 아니라 탐색키만 메모리에 올림

### 인덱싱의 종류

- 인덱스의 종류

  - 순서 인덱스
    - 특정 값에 대해 정렬된 순서 구조
  - 해시 인덱스
    - 버킷의 범위 안에서 값의 균일한 분포에 기초한 구조로 해시 함수가 어떤 값이 어느 버킷에 할당되는지 결정

- 인덱스의 평가 기준
  - 접근 시간
    - 데이터를 찾는데 걸리는 시간
  - 유지 비용
    - 새로운 데이터 삽입 및 기존 데이터 삭제 연산으로 인한 인덱스 구조 갱신 비용
  - 공간 비용
    - 인덱스 구조에 의해 사용되는 부가적인 공간 비용

## 순서 인덱스

### 순서 인덱스의 특징

- 탐색키로 정렬된 순차 파일에 대하여 레코드에 대한 빠른 접근이 가능하도록 구성한 인덱스

  - 탐색키를 정렬하여 해당 탐색키와 탐색키에 대한 레코드와의 연계를 통하여 인덱스 생성
    - EX) 실물세계에서는 백과사전의 옆면을 예로 들 수 있음 (강아지를 찾으려면 ㄱ..에서부터)

- 순서 인덱스의 종류
  - 밀집 인덱스
  - 희소 인덱스
  - 다단계 인덱스

### 순차 파일

- 연속된 레코드의 접근을 빠르게 하기 위해, 각각의 레코드 끝에 다음 레코드를 가르키는 포인터를 가지고 있음

### 인덱스 엔트리의 구조

![i1](/images/posts/db-indexing/i1.png)

- $b_2$로 부터 30바이트 떨어져 있음을 나타냄

### 밀집 인덱스

- 모든 레코드에 대해 `[탐색키 값 | 포인터]` 쌍을 유지

### 희소 인덱스

- 인덱스의 엔트리가 일부의 `탐색키 값`만을 유지
- 밀집 인덱스와 비교해서, 데이터 저장공간과 관련해 이점이 있지만 실행시간이 오래걸림

### 다단계 인덱스의 필요

- 4KB 크기의 한 블럭에 100개의 엔트리가 삽입될 때, 100,000,000 개의 레코드에 대한 순서 인덱스
  - 1,000,000개의 블럭 = 4GB의 공간 필요

* 인덱스 크기에 따른 검색 성능
  - 인덱스 크기 < 메모리 크기
    - 디스크 I/O가 줄어 탐색 시간이 축소
  - 인덱스 크기 > 메모리 크기
    - 저장된 블럭을 여러번 나누어 읽어야 하기 때문에 디스크 I/O 비용이 증가하여 탐색시간 증가

위 문제들을 해결하기 위해 다단계 인덱스가 등장

### 다단계 인덱스

- 내부 인덱스와 외부 인덱스로 구성

  - 외부 인덱스를 내부 인덱스보다 희소한 인덱스로 구성하여 엔트리의 포인터가 내부 인덱스 블럭을 지칭
  - 포인터가 가리키는 블럭을 스캔하여 원하는 레코드보다 작거나 같은 탐색키 값 중에 가장 큰 값을 가지는 레코드를 탐색

- 내부 인덱스는 1,000,000개의 블럭을 갖는 반면, 외부 인덱스는 100개의 블럭만 사용하여 작은 크기의 외부 인덱스로 메모리에 적재 가능

### 다단계 인덱스의 구조

![i2](/images/posts/db-indexing/i2.png)

<!-- ## $B^{+-}$ 트리 인덱스 -->
